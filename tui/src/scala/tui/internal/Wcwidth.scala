package tui
package internal

// copied from https://raw.githubusercontent.com/termd/termd/master/src/main/java/io/termd/core/util/Wcwidth.java

/*
 * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
 *
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 */
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** <p>See <a href="http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c">wcwidth.c</a></p>
  *
  * <p>This is an implementation of wcwidth() and wcswidth() (defined in IEEE Std 1002.1-2001) for Unicode.</p>
  *
  * http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
  *
  * <p>In fixed-width output devices, Latin characters all occupy a single "cell" position of equal width, whereas ideographic CJK characters occupy two such
  * cells. Interoperability between terminal-line applications and (teletype-style) character terminals using the UTF-8 encoding requires agreement on which
  * character should advance the cursor by how many cell positions. No established formal standards exist at present on which Unicode character shall occupy how
  * many cell positions on character terminals. These routines are a first attempt of defining such behavior based on simple rules applied to data provided by
  * the Unicode Consortium.</p>
  *
  * <p>For some graphical characters, the Unicode standard explicitly defines a character-cell width via the definition of the East Asian FullWidth (F), Wide
  * (W), Half-width (H), and Narrow (Na) classes. In all these cases, there is no ambiguity about which width a terminal shall use. For characters in the East
  * Asian Ambiguous (A) class, the width choice depends purely on a preference of backward compatibility with either historic CJK or Western practice. Choosing
  * single-width for these characters is easy to justify as the appropriate long-term solution, as the CJK practice of displaying these characters as
  * double-width comes from historic implementation simplicity (8-bit encoded characters were displayed single-width and 16-bit ones double-width, even for
  * Greek, Cyrillic, etc.) and not any typographic considerations.</p>
  *
  * <p>Much less clear is the choice of width for the Not East Asian (Neutral) class. Existing practice does not dictate a width for any of these characters. It
  * would nevertheless make sense typographically to allocate two character cells to characters such as for instance EM SPACE or VOLUME INTEGRAL, which cannot
  * be represented adequately with a single-width glyph. The following routines at present merely assign a single-cell width to all neutral characters, in the
  * interest of simplicity. This is not entirely satisfactory and should be reconsidered before establishing a formal standard in this area. At the moment, the
  * decision which Not East Asian (Neutral) characters should be represented by double-width glyphs cannot yet be answered by applying a simple rule from the
  * Unicode database content. Setting up a proper standard for the behavior of UTF-8 character terminals will require a careful analysis not only of each
  * Unicode character, but also of each presentation form, something the author of these routines has avoided to do so far.</p>
  *
  * <p>http://www.unicode.org/unicode/reports/tr11/</p>
  */
object Wcwidth {

  /** sorted list of non-overlapping intervals of non-spacing characters generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c"
    */
  private val COMBINING = Array(
    Array(0x0300, 0x036f),
    Array(0x0483, 0x0486),
    Array(0x0488, 0x0489),
    Array(0x0591, 0x05bd),
    Array(0x05bf, 0x05bf),
    Array(0x05c1, 0x05c2),
    Array(0x05c4, 0x05c5),
    Array(0x05c7, 0x05c7),
    Array(0x0600, 0x0603),
    Array(0x0610, 0x0615),
    Array(0x064b, 0x065e),
    Array(0x0670, 0x0670),
    Array(0x06d6, 0x06e4),
    Array(0x06e7, 0x06e8),
    Array(0x06ea, 0x06ed),
    Array(0x070f, 0x070f),
    Array(0x0711, 0x0711),
    Array(0x0730, 0x074a),
    Array(0x07a6, 0x07b0),
    Array(0x07eb, 0x07f3),
    Array(0x0901, 0x0902),
    Array(0x093c, 0x093c),
    Array(0x0941, 0x0948),
    Array(0x094d, 0x094d),
    Array(0x0951, 0x0954),
    Array(0x0962, 0x0963),
    Array(0x0981, 0x0981),
    Array(0x09bc, 0x09bc),
    Array(0x09c1, 0x09c4),
    Array(0x09cd, 0x09cd),
    Array(0x09e2, 0x09e3),
    Array(0x0a01, 0x0a02),
    Array(0x0a3c, 0x0a3c),
    Array(0x0a41, 0x0a42),
    Array(0x0a47, 0x0a48),
    Array(0x0a4b, 0x0a4d),
    Array(0x0a70, 0x0a71),
    Array(0x0a81, 0x0a82),
    Array(0x0abc, 0x0abc),
    Array(0x0ac1, 0x0ac5),
    Array(0x0ac7, 0x0ac8),
    Array(0x0acd, 0x0acd),
    Array(0x0ae2, 0x0ae3),
    Array(0x0b01, 0x0b01),
    Array(0x0b3c, 0x0b3c),
    Array(0x0b3f, 0x0b3f),
    Array(0x0b41, 0x0b43),
    Array(0x0b4d, 0x0b4d),
    Array(0x0b56, 0x0b56),
    Array(0x0b82, 0x0b82),
    Array(0x0bc0, 0x0bc0),
    Array(0x0bcd, 0x0bcd),
    Array(0x0c3e, 0x0c40),
    Array(0x0c46, 0x0c48),
    Array(0x0c4a, 0x0c4d),
    Array(0x0c55, 0x0c56),
    Array(0x0cbc, 0x0cbc),
    Array(0x0cbf, 0x0cbf),
    Array(0x0cc6, 0x0cc6),
    Array(0x0ccc, 0x0ccd),
    Array(0x0ce2, 0x0ce3),
    Array(0x0d41, 0x0d43),
    Array(0x0d4d, 0x0d4d),
    Array(0x0dca, 0x0dca),
    Array(0x0dd2, 0x0dd4),
    Array(0x0dd6, 0x0dd6),
    Array(0x0e31, 0x0e31),
    Array(0x0e34, 0x0e3a),
    Array(0x0e47, 0x0e4e),
    Array(0x0eb1, 0x0eb1),
    Array(0x0eb4, 0x0eb9),
    Array(0x0ebb, 0x0ebc),
    Array(0x0ec8, 0x0ecd),
    Array(0x0f18, 0x0f19),
    Array(0x0f35, 0x0f35),
    Array(0x0f37, 0x0f37),
    Array(0x0f39, 0x0f39),
    Array(0x0f71, 0x0f7e),
    Array(0x0f80, 0x0f84),
    Array(0x0f86, 0x0f87),
    Array(0x0f90, 0x0f97),
    Array(0x0f99, 0x0fbc),
    Array(0x0fc6, 0x0fc6),
    Array(0x102d, 0x1030),
    Array(0x1032, 0x1032),
    Array(0x1036, 0x1037),
    Array(0x1039, 0x1039),
    Array(0x1058, 0x1059),
    Array(0x1160, 0x11ff),
    Array(0x135f, 0x135f),
    Array(0x1712, 0x1714),
    Array(0x1732, 0x1734),
    Array(0x1752, 0x1753),
    Array(0x1772, 0x1773),
    Array(0x17b4, 0x17b5),
    Array(0x17b7, 0x17bd),
    Array(0x17c6, 0x17c6),
    Array(0x17c9, 0x17d3),
    Array(0x17dd, 0x17dd),
    Array(0x180b, 0x180d),
    Array(0x18a9, 0x18a9),
    Array(0x1920, 0x1922),
    Array(0x1927, 0x1928),
    Array(0x1932, 0x1932),
    Array(0x1939, 0x193b),
    Array(0x1a17, 0x1a18),
    Array(0x1b00, 0x1b03),
    Array(0x1b34, 0x1b34),
    Array(0x1b36, 0x1b3a),
    Array(0x1b3c, 0x1b3c),
    Array(0x1b42, 0x1b42),
    Array(0x1b6b, 0x1b73),
    Array(0x1dc0, 0x1dca),
    Array(0x1dfe, 0x1dff),
    Array(0x200b, 0x200f),
    Array(0x202a, 0x202e),
    Array(0x2060, 0x2063),
    Array(0x206a, 0x206f),
    Array(0x20d0, 0x20ef),
    Array(0x302a, 0x302f),
    Array(0x3099, 0x309a),
    Array(0xa806, 0xa806),
    Array(0xa80b, 0xa80b),
    Array(0xa825, 0xa826),
    Array(0xfb1e, 0xfb1e),
    Array(0xfe00, 0xfe0f),
    Array(0xfe20, 0xfe23),
    Array(0xfeff, 0xfeff),
    Array(0xfff9, 0xfffb),
    Array(0x10a01, 0x10a03),
    Array(0x10a05, 0x10a06),
    Array(0x10a0c, 0x10a0f),
    Array(0x10a38, 0x10a3a),
    Array(0x10a3f, 0x10a3f),
    Array(0x1d167, 0x1d169),
    Array(0x1d173, 0x1d182),
    Array(0x1d185, 0x1d18b),
    Array(0x1d1aa, 0x1d1ad),
    Array(0x1d242, 0x1d244),
    Array(0xe0001, 0xe0001),
    Array(0xe0020, 0xe007f),
    Array(0xe0100, 0xe01ef)
  )

  private def bisearch(ucs: Int): Boolean = {
    var min = 0
    var mid = 0
    var max = COMBINING.length - 1
    if (ucs < COMBINING(0)(0) || ucs > COMBINING(max)(1)) return false
    while (max >= min) {
      mid = (min + max) / 2
      if (ucs > COMBINING(mid)(1)) min = mid + 1
      else if (ucs < COMBINING(mid)(0)) max = mid - 1
      else return true
    }
    false
  }

  /** See : http://www.cl.cam.ac.uk/%7Emgk25/ucs/wcwidth.c
    *
    * The following two functions define the column width of an ISO 10646 character as follows:
    *
    *   - The null character (U+0000) has a column width of 0.
    *
    *   - Other C0/C1 control characters and DEL will lead to a return value of -1.
    *
    *   - Non-spacing and enclosing combining characters (general category code Mn or Me in the Unicode database) have a column width of 0.
    *
    *   - SOFT HYPHEN (U+00AD) has a column width of 1.
    *
    *   - Other format characters (general category code Cf in the Unicode database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
    *
    *   - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF) have a column width of 0.
    *
    *   - Spacing characters in the East Asian Wide (W) or East Asian Full-width (F) category as defined in Unicode Technical Report #11 have a column width of
    *     2.
    *
    *   - All remaining characters (including all printable ISO 8859-1 and WGL4 characters, Unicode control characters, etc.) have a column width of 1.
    *
    * This implementation assumes that wchar_t characters are encoded in ISO 10646.
    */
  def of(codePoint: Int): Int = {
    // test for 8-bit control characters
    if (codePoint == 0) return 0
    if (codePoint < 32 || (codePoint >= 0x7f && codePoint < 0xa0)) return -1
    // binary search in table of non-spacing characters
    if (bisearch(codePoint)) return 0
    // if we arrive here, ucs is not a combining or C0/C1 control character
    1 + (if (
           codePoint >= 0x1100 && (codePoint <= 0x115f || // Hangul Jamo init. consonants
             codePoint == 0x2329 || codePoint == 0x232a || (codePoint >= 0x2e80 && codePoint <= 0xa4cf && codePoint != 0x303f) || // CJK ... Yi
             (codePoint >= 0xac00 && codePoint <= 0xd7a3) || // Hangul Syllables
             (codePoint >= 0xf900 && codePoint <= 0xfaff) || // CJK Compatibility Ideographs
             (codePoint >= 0xfe10 && codePoint <= 0xfe19) || // Vertical forms
             (codePoint >= 0xfe30 && codePoint <= 0xfe6f) || // CJK Compatibility Forms
             (codePoint >= 0xff00 && codePoint <= 0xff60) || // Fullwidth Forms
             (codePoint >= 0xffe0 && codePoint <= 0xffe6) || (codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd))
         ) 1
         else 0)
  }
}
